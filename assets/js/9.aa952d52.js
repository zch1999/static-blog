(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{356:function(e,n,r){e.exports=r.p+"assets/img/require_module.1ea3e7f0.jpeg"},357:function(e,n,r){e.exports=r.p+"assets/img/module.b6e028d3.png"},401:function(e,n,r){"use strict";r.r(n);var s=r(42),_=Object(s.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"commonjs规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#commonjs规范"}},[e._v("#")]),e._v(" CommonJS规范")]),e._v(" "),s("h2",{attrs:{id:"commonjs的模块规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#commonjs的模块规范"}},[e._v("#")]),e._v(" CommonJS的模块规范")]),e._v(" "),s("ol",[s("li",[e._v("模块引用"),s("br"),e._v("\n在CommonJS规范中，存在require()方法，这个方法接受一个模块标识，以此引入一个模块的API到当前的上下文中。")]),e._v(" "),s("li",[e._v("模块定义"),s("br"),e._v("\n在模块中，上下文提供require()方法来引入外部模块。对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且他是唯一的导出接口。在模块中，还存在一个module对象，它代表模块自身，exports是module的属性。")]),e._v(" "),s("li",[e._v("模块标识"),s("br"),e._v("\n模块标识其实就是传递给require()方法的参数，它必须是符合 小驼峰命名的字符串，或者是相对路径，绝对路径。\n每个模块具有独立的空间，它们互不干扰，在引用的时候也显得干净利落,用户也"),s("strong",[e._v("完全不用考虑变量污染")]),e._v("。\n"),s("img",{attrs:{src:r(356),alt:"avatar"}})])]),e._v(" "),s("h2",{attrs:{id:"node的模块实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node的模块实现"}},[e._v("#")]),e._v(" Node的模块实现")]),e._v(" "),s("p",[e._v("在Node中引入模块，需要经历一下3个步骤："),s("br")]),e._v(" "),s("ol",[s("li",[e._v("路径分析")]),e._v(" "),s("li",[e._v("文件定位")]),e._v(" "),s("li",[e._v("编译执行\n而模块又分为两类，一类是核心模块，既Node提供的模块；一类是文件模块，既用户自己编写的模块。")])]),e._v(" "),s("ul",[s("li",[e._v("核心模块，在Node源代码的编译过程中，编译成了二进制模块，在Node进程启动时，部分核心模块直接加载进了内存中，所以部分核心模块引入时，文件定位和编译执行被忽略掉，路径分析也优先判断，所以它的加载速度是最快的")]),e._v(" "),s("li",[e._v("文件模型是运行时动态加载，需要完整的三个步骤流程才行，所速度会比核心模块慢。")])]),e._v(" "),s("p",[e._v("需要注意的是，Node和前端浏览器会缓存静态脚本文件以提高性能一样，Node也会对引入的模块进行缓存，不过浏览器仅仅缓存文件，而"),s("strong",[e._v("Node缓存的是编译和执行之后的对象")]),e._v("（require对相同模块的二次加载一律采用缓存优先的方式，不过核心模块的缓存检查还是先于文件模块的缓存检查）")]),e._v(" "),s("h3",{attrs:{id:"路径分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#路径分析"}},[e._v("#")]),e._v(" 路径分析")]),e._v(" "),s("ul",[s("li",[e._v("模块标识符分析\n模块标识符在Node中主要分为一下积几类：")])]),e._v(" "),s("ol",[s("li",[e._v("核心模块")]),e._v(" "),s("li",[e._v("以.或..开始的相对路径文件模块")]),e._v(" "),s("li",[e._v("以/开始的绝对路径模块文件")]),e._v(" "),s("li",[e._v("非路径形式的文件模块")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("核心模块\n加载优先级仅次于缓存加载，因为他在Node的源代码编译过程中已经编译成了二进制代码。")])]),e._v(" "),s("li",[s("p",[e._v("路径形式的文件模块\n分析模块时，require()方法会将路径转为真实路径，以真实路径作为索引，并将编译执行后的结果存放到缓存中，以便二次加载。")])]),e._v(" "),s("li",[s("p",[e._v("自定义模块\n主要采用一种叫模块路径的查找策略，模块路径具体表现为一个路径组成的数组。"),s("br"),e._v("\n这个我们可以编写一个js文件查看，例如："),s("br")])])]),e._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[e._v("console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("module"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("paths"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),s("p",[e._v("我们执行这个文件可以得到一下输出："),s("br"),e._v(" "),s("img",{attrs:{src:r(357),alt:"avatar"}})]),e._v(" "),s("p",[e._v("模块路径的生成规则："),s("br"),e._v("\n❑ 当前文件目录下的node_modules目录。"),s("br"),e._v("\n❑ 父目录下的node_modules目录。"),s("br"),e._v("\n❑ 父目录的父目录下的node_modules目录。"),s("br"),e._v("\n❑ 沿路径向上逐级递归，直到根目录下的node_modules目录。"),s("br")]),e._v(" "),s("h3",{attrs:{id:"文件定位"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文件定位"}},[e._v("#")]),e._v(" 文件定位")]),e._v(" "),s("p",[e._v("缓存加载不需要路径分析，问价定位和编译执行过程")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("文件扩展名分析\nCommonJS模块允许在标识符中不包含文件扩展名，它会按.js, .json, .node的次序以此补全，依次尝试。"),s("br"),e._v("\n在尝试过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为node是单线程的，所以这里会引起性能问题。"),s("br"),e._v("\n小诀窍：1. 如果是.node 或 .json文件，我们可以加上扩展名。 2. 同步配合缓存")])]),e._v(" "),s("li",[s("p",[e._v("目录分析和包\nrequire()在通过文件扩展民查找文件之后，没有找到响应文件，但获得了一个目录，此时Node会将鲁姆当作一个包来处理。"),s("br"),e._v("\nNode在当期目录下查找package.json，通过JSON.parse()解析出包描述对象，去除main属性指定的文件名进行定位，并进行文件扩展名分析，如果main指定的文件错误，或者没有package.json文件，Node默认将index当作默认文件名，进行文件扩展名分析。"),s("br"),e._v("\nrequire()通过模块路径路径查找，没找到就进入下一个模块中。如果都没找到，就报错")])])]),e._v(" "),s("h2",{attrs:{id:"模块编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块编译"}},[e._v("#")]),e._v(" 模块编译")]),e._v(" "),s("p",[e._v("定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。"),s("br")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("不同的文件扩展名，载入方法也不同："),s("br"),e._v("\n❑ .js文件。通过fs模块同步读取文件后编译执行。"),s("br"),e._v("\n❑ .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。"),s("br"),e._v("\n❑ .json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。"),s("br"),e._v("\n❑ 其余扩展名文件。它们都被当做．js文件载入。"),s("br"),e._v("\n每一个成功编译的模块都会将起文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。")])]),e._v(" "),s("li",[s("p",[e._v("javascript模块的编译\njavascript模块会被Node头尾包装，在头部添加了(function (exports, require, module, __filename, __dirname){\\n,在尾部添加了\\n}"),s("br"),e._v("\n这样每个模块之间都进行了作用域隔离，不染全局变量。包装后的代码会通过vm原生模块的runInThisContext()方法执行(类似eval,只具有明确上下文，不污染全局)，返回一个具体的function对象。"),s("br"),e._v("\n再执行之后，模块的exports属性返回给了调用方。exports属性上的任何方法都可以被外部调用到，但是模块中的其余变量则不可被调用。")])]),e._v(" "),s("li",[s("p",[e._v("c/c++模块的编译\nNode调用process_dlopen()方法进行加载和执行。window和*nix平台下分别有不同的实现，通过"),s("strong",[e._v("linuv兼容层")]),e._v("进行了封装。"),s("br"),e._v("\n实际上.node文件只需要加载和执行。在执行的过程中，模块的exports对象与.node模块产生联系，然后返回给调用者。所以c/c++模块执行效率会更高些。")])]),e._v(" "),s("li",[s("p",[e._v("JSON模块的编译\nNdoe通过fs模块同步读取JSON文件的内容之后，调用JSON.parse()方法得到对象，然后将它赋值给模块对象的exports，以供外部调用。"),s("br"),e._v("\n根据这个，我们将JSON文件用在项目的配置文件时比较有用，我们可以不用fs模块去异步读取和解析，只需要require()即可。")])])])])}),[],!1,null,null,null);n.default=_.exports}}]);